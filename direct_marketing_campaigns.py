# -*- coding: utf-8 -*-
"""direct marketing campaigns

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1w7tKXl4Vq281rv3GPj3VStWGO3jCB4i3
"""

import pandas as pd
import numpy as np

"""**Dataset** **Information**

**The data is related with direct marketing campaigns of a Portuguese banking institution. The marketing campaigns were based on phone calls. Often, more than one contact to the same client was required, in order to access if the product (bank term deposit) would be ('yes') or not ('no') subscribed.**

*Source : https://archive.ics.uci.edu/dataset/222/bank+marketing*
"""

from ucimlrepo import fetch_ucirepo

# fetch dataset
bank_marketing = fetch_ucirepo(id=222)

# data (as pandas dataframes)
X = bank_marketing.data.features
y = bank_marketing.data.targets

# metadata
print(bank_marketing.metadata)

# variable information
print(bank_marketing.variables)

#rejoining the dataset

df = X.join(y)
df.head(10)

df.shape

df1 = df.head(300)

df1.shape

df1.isnull().sum() # CHECKING NULLS

df1.head(10)

#drop the null columns

df2 = df1.drop(['contact','poutcome'], axis=1)

# Fill missing in 'job' with the most common job
most_common_job = df2['job'].mode()[0]

most_common_job

df2['job'] = df2['job'].fillna(most_common_job) # filled the null with most common

most_common_edu = df2['education'].mode()[0]

most_common_edu

df2['education'] = df2['education'].fillna(most_common_edu) # filled the null with most common

df2.isnull().sum()

df2.head(20)

# descriptive analysis


df2.describe()

import matplotlib.pyplot as plt
import seaborn as sns

"""# Descriptive Analysis

## 1.Age
"""

print("Average age:", df2['age'].mean())
print("Min age:", df2['age'].min())
print("Max age:", df2['age'].max())
print("Median age:", df2['age'].median())
print("Standard Deviation:", df2['age'].std())

sns.boxplot(x=df2['age'])
plt.title("Boxplot of Age")
plt.show()

# Histogram with KDE
sns.histplot(df2['age'], bins=15, kde=True)
plt.title("Age Distribution")
plt.show()

df2['job'].unique()

"""## 2.Job"""

# Count of each job type
job_counts = df2['job'].value_counts()
print(job_counts)

# Bar plot
sns.countplot(y='job', data=df2, order=job_counts.index)
plt.title("Client Count by Job Type")
plt.xlabel("Count")
plt.ylabel("Job")
plt.show()

"""## 3.Education"""

# Count of each job type
education_counts = df2['education'].value_counts()
print(education_counts)

sns.countplot(y='education', data=df2, order=education_counts.index)
plt.title("Client Count by Education Type")
plt.xlabel("Count")
plt.ylabel("Education")
plt.show()

"""## 4.Housing"""

housing_counts = df2['housing'].value_counts()
housing_counts

sns.countplot(y='housing', data=df2, order=housing_counts.index)
plt.title("Client Count by Housig")
plt.xlabel("Count")
plt.ylabel("House")
plt.show()

#pie chart
plt.figure(figsize=(6,6))
plt.pie(housing_counts, labels=housing_counts.index, autopct='%1.1f%%', startangle=90, colors=['#66b3ff', '#99ff99'])
plt.title("Proportion of Clients with Housing Loans")
plt.axis('equal')
plt.show()

"""## 5.Martial Status"""

marital_counts = df2['marital'].value_counts()
marital_counts

# Labels and colors
labels = marital_counts.index
colors = ['#66b3ff', '#ff9999', '#99ff99']

# Plot
plt.figure(figsize=(6,6))
plt.pie(
    marital_counts,
    labels=labels,
    autopct='%1.1f%%',
    startangle=90,
    colors=colors,
    wedgeprops={'edgecolor': 'black'}
)
plt.title("Client Distribution by Marital Status", fontsize=14)
plt.axis('equal')
plt.show()

"""# Diagnostic Analysis"""

# Subscription rate by job
job_analysis = df2.groupby('job')['y'].value_counts(normalize=True).unstack().fillna(0)
print(job_analysis)

"""üìâ **Overall Insight**

  Across the board, subscription rates are very low for all job types in this filtered sample.

  Several job categories had zero conversions: blue-collar, entrepreneur, retired, etc.

  The best-performing group, ironically, is admin. with only 8.3%, which is still quite low.
"""

# Visualize
sns.set_style("whitegrid")

# Plot
ax = job_analysis.plot(
    kind='barh',
    stacked=True,
    figsize=(10, 6),
    color=['#ff9999', '#66b3ff'],  # Colors for 'no' and 'yes'
)

# Titles and labels
plt.title("Subscription Rate by Job", fontsize=14)
plt.xlabel("Proportion of Clients", fontsize=12)
plt.ylabel("Job Type", fontsize=12)
plt.legend(title="Subscribed", loc='center left', bbox_to_anchor=(1, 0.5))

# Add percentage labels inside the bars
for i, (no, yes) in enumerate(zip(job_analysis['no'], job_analysis['yes'])):
    plt.text(no / 2, i, f"{no:.0%}", va='center', ha='center', color='black')
    plt.text(no + (yes / 2), i, f"{yes:.0%}", va='center', ha='center', color='white')

plt.tight_layout()
plt.show()

# Subscription rate by education
edu_analysis = df2.groupby('education')['y'].value_counts(normalize=True).unstack().fillna(0)
edu_analysis

"""## üìâ Overall Insight

 The higher the education level, the slightly higher the likelihood of subscribing.

 However, even with tertiary education, the success rate is very low.

 Primary education clients had 0% subscription in this filtered sample.
"""

# Set a clean style
sns.set_style("whitegrid")

# Create a horizontal stacked bar chart
ax = edu_analysis.plot(
    kind='barh',
    stacked=True,
    figsize=(8, 5),
    color=['#ff9999', '#66b3ff'],  # 'no' = red-ish, 'yes' = blue
)

# Title and labels
plt.title("Subscription Rate by Education Level", fontsize=14)
plt.xlabel("Proportion of Clients", fontsize=12)
plt.ylabel("Education Level", fontsize=12)
plt.legend(title="Subscribed", loc='center left', bbox_to_anchor=(1, 0.5))

# Add % labels inside bars
for i, (no, yes) in enumerate(zip(edu_analysis['no'], edu_analysis['yes'])):
    plt.text(no / 2, i, f"{no:.0%}", va='center', ha='center', color='black')
    plt.text(no + (yes / 2), i, f"{yes:.0%}", va='center', ha='center', color='white')

plt.tight_layout()
plt.show()

# Subscription rate by education
marital_analysis = df2.groupby('marital')['y'].value_counts(normalize=True).unstack().fillna(0)
marital_analysis

# Set a clean style
sns.set_style("whitegrid")

# Create a horizontal stacked bar chart
ax = marital_analysis.plot(
    kind='barh',
    stacked=True,
    figsize=(8, 5),
    color=['#ff9999', '#66b3ff'],  # 'no' = red-ish, 'yes' = blue
)

# Title and labels
plt.title("Subscription Rate by maritial status", fontsize=14)
plt.xlabel("Proportion of Clients", fontsize=12)
plt.ylabel("marital status", fontsize=12)
plt.legend(title="Subscribed", loc='center left', bbox_to_anchor=(1, 0.5))

# Add % labels inside bars
for i, (no, yes) in enumerate(zip(marital_analysis['no'], marital_analysis['yes'])):
    plt.text(no / 2, i, f"{no:.0%}", va='center', ha='center', color='black')
    plt.text(no + (yes / 2), i, f"{yes:.0%}", va='center', ha='center', color='white')

plt.tight_layout()
plt.show()

"""# 3.Predictive Analysis"""

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score
from sklearn.preprocessing import StandardScaler

# Encode categorical variables
df_encoded = df2.copy()

df_encoded = df_encoded.dropna()

for col in ['job', 'marital', 'education', 'default', 'housing', 'loan', 'month', 'day_of_week']:
    df_encoded[col] = LabelEncoder().fit_transform(df_encoded[col])

# Target encoding
df_encoded['y'] = df_encoded['y'].map({'no': 0, 'yes': 1})

# Features and label
X = df_encoded.drop('y', axis=1)
y = df_encoded['y']



scaler = StandardScaler()
x_scaled = scaler.fit_transform(X)

# Train-test split
X_train, X_test, y_train, y_test = train_test_split(
    x_scaled, y, test_size=0.3, random_state=42, stratify=y
)

# Logistic Regression
model = LogisticRegression(max_iter=1000)
model.fit(X_train, y_train)
y_pred = model.predict(X_test)

# Evaluation

print("\nClassification Report:")
print(classification_report(y_test, y_pred))

print("Accuracy Score:", accuracy_score(y_test, y_pred))

"""Analyzing a bank marketing dataset where the target variable y indicates whether a client subscribed to a term deposit (yes or no).

Earlier analysis showed:

  Very low subscription rates overall.

  Certain jobs and education levels had slightly better subscription likelihood.

  The model had trouble identifying positive cases due to class imbalance.

üßë‚Äçüíº 1. Focus on Specific Job Segments

  Jobs like admin. and management had some positive responses.

  Jobs like blue-collar, retired, unemployed, and student had zero subscriptions.

‚úÖ Recommendation:

  Prioritize marketing efforts toward job types with higher historical subscription rates.

  Reduce outreach to segments with historically no conversion unless product offerings are revised.

üéì 2. Target Higher-Education Clients

  Clients with tertiary education showed a higher subscription rate (~3.3%) compared to secondary (2%) and primary (0%).

‚úÖ Recommendation:

  Design tailored campaigns for college-educated clients with more complex or long-term financial products.

  Use personalized messaging and online channels more suited to this group.
"""